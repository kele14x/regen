{#- This macro generate the port declaration line -#}
{%- macro field_port(register, field, is_last=False) -%}
    {%- if field.access == 'RW' -%}
output var
    {%- else -%}
input var
    {%- endif -%}
    {%- if field.bit_width > 1 %} [{{ field.bit_width - 1 }}:0] {% else %} {% endif -%}
{{ register.name }}_{{ field.name }}
    {%- if not is_last %},{% endif -%}
{%- endmacro -%}

{#- This macro generate the register writing process -#}
{%- macro field_write_proc(register, field) -%}
    always_ff @(posedge aclk) begin
        if (!aresetn) begin
            {{ register.name }}_{{ field.name }} <= {{ field.reset }};
        end else if (wr_req && wr_addr == {{ register.address_offset }}) begin
            {{ register.name }}_{{ field.name }} <= wr_data[{{ field.bit_width + field.bit_offset - 1 }}:{{ field.bit_offset }}];
        end
    end
{%- endmacro -%}

{#- This macro generate the register reading process -#}
{%- macro read_proc(registers) -%}
    always_ff @(posedge aclk) begin
        if (!aresetn) begin
            rd_data <= '0;
        end else if (wr_req) begin
            rd_data <= '0;
            case (rd_addr)
    {% for r in registers %}
                {{ r.address_offset }}: begin
        {% for f in r.fields %}
                    rd_data[{{ f.bit_width + f.bit_offset - 1 }}:{{ f.bit_offset }}] <= {{ r.name }}_{{ f.name }};
        {% endfor %}
                end
    {% endfor %}
                default: rd_data <= 'hDEADBEEF;
            endcase
        end
    end
{%- endmacro -%}

//*****************************************************************************
// File: {{ block.name | lower }}_regs.sv
//*****************************************************************************
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//*****************************************************************************
`timescale 1 ns / 1 ps `default_nettype none

module {{ block.name | lower }}_regs #(
    parameter C_ADDR_WIDTH = {{ block.address_width }},
    parameter C_DATA_WIDTH = {{ block.width }},
    parameter C_BASE_ADDR  = {{ block.base_address }}
) (
    // AXI4-Lite Interface
    //--------------------
    // AXI clock & reset
    input  var                        aclk         ,
    input  var                        aresetn      ,
    // Write address channel
    input  var [    C_ADDR_WIDTH-1:0] s_axi_awaddr ,
    input  var [                 2:0] s_axi_awprot ,
    input  var                        s_axi_awvalid,
    output var                        s_axi_awready,
    // Write data channel
    input  var [    C_DATA_WIDTH-1:0] s_axi_wdata  ,
    input  var [(C_DATA_WIDTH/8)-1:0] s_axi_wstrb  ,
    input  var                        s_axi_wvalid ,
    output var                        s_axi_wready ,
    // Write response channel
    output var [                 1:0] s_axi_bresp  ,
    output var                        s_axi_bvalid ,
    input  var                        s_axi_bready ,
    // Read address channel
    input  var [    C_ADDR_WIDTH-1:0] s_axi_araddr ,
    input  var [                 2:0] s_axi_arprot ,
    input  var                        s_axi_arvalid,
    output var                        s_axi_arready,
    // Read data channel
    output var [    C_DATA_WIDTH-1:0] s_axi_rdata  ,
    output var [                 1:0] s_axi_rresp  ,
    output var                        s_axi_rvalid ,
    input  var                        s_axi_rready ,
    // Register Interface
    //-------------------
    {% for r in block.registers %}
    // {{ r.name }}
        {% set outer_loop = loop %}
        {% for f in r.fields %}
    {{ field_port(r, f, loop.last and outer_loop.last) }}
        {% endfor %}
    {% endfor %}
);

    initial begin
        if (!((C_DATA_WIDTH == 32) || (C_DATA_WIDTH == 64))) begin
            $error("AXI-4 Lite interface only support C_DATA_WIDTH=32 or 64");
        end
    end

    // RRESP/BRESP
    localparam C_RESP_OKAY   = 2'b00; //   OKAY, normal access success
    localparam C_RESP_EXOKAY = 2'b01; // EXOKAY, exclusive access success
    localparam C_RESP_SLVERR = 2'b10; // SLVERR, slave error
    localparam C_RESP_DECERR = 2'b11; // DECERR, decoder error


    // Write State Machine
    //--------------------

    enum {
        S_WRRST , // in reset
        S_WRIDLE, // idle, waiting for both write address and write data
        S_WRADDR, // write data is provided, waiting for write address
        S_WRDATA, // write address is provided, waiting for write data
        S_WRWAIT, // both address data is provided, wait for 1 clock for decode
        S_WRRESP  // response to axi master
    } wr_state, wr_state_next;

    logic       wr_valid, wr_addr_valid, wr_data_valid;

    always_ff @(posedge aclk) begin
        if (!aresetn) begin
            wr_state <= S_WRRST;
        end else begin
            wr_state <= wr_state_next;
        end
    end

    always_comb begin
        case (wr_state)
            S_WRRST  : wr_state_next = S_WRIDLE;
            S_WRIDLE : wr_state_next = (s_axi_awvalid && s_axi_wvalid) ? S_WRWAIT :
                                        s_axi_awvalid ? S_WRADDR :
                                        s_axi_wvalid  ? S_WRDATA :
                                        S_WRIDLE;
            S_WRADDR : wr_state_next = !s_axi_wvalid  ? S_WRADDR : S_WRWAIT;
            S_WRDATA : wr_state_next = !s_axi_awvalid ? S_WRDATA : S_WRWAIT;
            S_WRWAIT : wr_state_next = S_WRRESP;
            S_WRRESP : wr_state_next = !s_axi_bready  ? S_WRRESP : S_WRIDLE;
            default  : wr_state_next = S_WRRST;
        endcase
    end

    assign wr_valid = ((wr_state == S_WRIDLE) && s_axi_awvalid && s_axi_wvalid) ||
        ((wr_state == S_WRADDR) && s_axi_wvalid) ||
        ((wr_state == S_WRDATA) && s_axi_awvalid);

    assign wr_addr_valid = ((wr_state == S_WRIDLE) && s_axi_awvalid) ||
        ((wr_state == S_WRDATA) && s_axi_awvalid);

    assign wr_data_valid = ((wr_state == S_WRIDLE) && s_axi_wvalid) ||
        ((wr_state == S_WRADDR) && s_axi_wvalid);


    // Write Address Channel
    //-----------------------

    logic [C_ADDR_WIDTH-1:0] wr_addr;

    // We are waiting for both write address and write data, but only write
    // address is provided. Register it for later use.
    always_ff @(posedge aclk) begin
        if (!aresetn) begin
            wr_addr <= 'd0;
        end else if (wr_addr_valid) begin
            wr_addr <= s_axi_awaddr[C_ADDR_WIDTH-1:2];
        end
    end

    // Slave can accept write address if idle, or if only write data is
    // provided.
    always_ff @(posedge aclk) begin
        if (!aresetn) begin
            s_axi_awready <= 1'b0;
        end else begin
            s_axi_awready <= (wr_state_next == S_WRIDLE || wr_state_next == S_WRDATA);
        end
    end


    // Write Data Channel
    //--------------------

    logic [  C_DATA_WIDTH-1:0] wr_data;
    logic [C_DATA_WIDTH/8-1:0] wr_be;

    // We are waiting for both write address and write data, but only write
    // data is provided. Register it for later use.
    always_ff @(posedge aclk) begin
        if (!aresetn) begin
            wr_data <= 'd0;
            wr_be   <= 'd0;
        end if (wr_data_valid) begin
            wr_data <= s_axi_wdata;
            wr_be   <= s_axi_wstrb;
        end
    end

    // Slave can accpet write data if idle, or if only write address is
    // provided.
    always_ff @(posedge aclk) begin
        if (!aresetn) begin
            s_axi_wready <= 1'b0;
        end else begin
            s_axi_wready <= (wr_state_next == S_WRIDLE || wr_state_next == S_WRADDR);
        end
    end


    // Write response channel
    //------------------------

    logic wr_req;
    logic wr_err;

    always_ff @(posedge aclk) begin
        if (!aresetn) begin
            wr_req <= 1'b0;
        end else begin
            wr_req <= wr_valid;
        end
    end

    always_ff @(posedge aclk) begin
        if (!aresetn) begin
            s_axi_bvalid <= 1'b0;
        end else begin
            s_axi_bvalid <= (wr_state_next == S_WRRESP);
        end
    end

    assign s_axi_bresp = C_RESP_OKAY;


    // Read State Machine
    //-------------------

    // Read Iteration Interval = 2 (back-to-back read transaction)
    // Read Latency = 2 (from AWADDR transaction to RDATA transaction)

    enum {
        S_RDRST ,
        S_RDIDLE,
        S_RDWAIT,
        S_RDRESP
    } rd_state, rd_state_next;

    logic       rd_valid;
    logic       rd_ack;
    logic [4:0] rd_cnt;

    always_ff @(posedge aclk) begin
        if (!aresetn) begin
            rd_state <= S_RDRST;
        end else begin
            rd_state <= rd_state_next;
        end
    end

    always_comb begin
        case(rd_state)
            S_RDRST  : rd_state_next = S_RDIDLE;
            S_RDIDLE : rd_state_next = !s_axi_arvalid ? S_RDIDLE : S_RDWAIT;
            S_RDWAIT : rd_state_next = !(rd_ack || rd_cnt[4]) ? S_RDWAIT : S_RDRESP;
            S_RDRESP : rd_state_next = !s_axi_rready  ? S_RDRESP : S_RDIDLE;
            default  : rd_state_next = S_RDRST;
        endcase
    end

    assign rd_valid = (rd_state == S_RDIDLE) && s_axi_arvalid;


    // Read Address Channel
    //----------------------

    logic [C_ADDR_WIDTH-1:0] rd_addr;

    always_ff @(posedge aclk) begin
        if (!aresetn) begin
            rd_addr <= 'd0;
        end else if (rd_valid) begin
            rd_addr <= s_axi_araddr[C_ADDR_WIDTH-1:3];
        end
    end

    always_ff @(posedge aclk) begin
        if (!aresetn) begin
            s_axi_arready <= 1'b0;
        end else begin
            s_axi_arready <= (rd_state_next == S_RDIDLE);
        end
    end


    // Read Data/Response Channel
    //---------------------------

    logic                    rd_req;
    logic [C_DATA_WIDTH-1:0] rd_data;

    always_ff @(posedge aclk) begin
        if (!aresetn) begin
            rd_req <= 1'b0;
        end else begin
            rd_req <= rd_valid;
        end
    end

    always_ff @(posedge aclk) begin
        if (!aresetn) begin
            s_axi_rvalid <= 1'b0;
        end else begin
            s_axi_rvalid <= (rd_state_next == S_RDRESP);
        end
    end

    // Time out counter of waiting for `rd_ack`
    always_ff @ (posedge aclk) begin
        if (!aresetn) begin
            rd_cnt <= 5'h1F;
        end else if (rd_state_next == S_RDWAIT) begin
            rd_cnt <= rd_cnt + 1;
        end else begin
            rd_cnt <= 5'h1F;
        end
    end

    always_ff @(posedge aclk) begin
        if (!aresetn) begin
            s_axi_rdata <= 0;
        end else if (rd_state == S_RDWAIT && rd_ack) begin
            s_axi_rdata <= rd_data;
        end else if (rd_state == S_RDWAIT && rd_cnt[4]) begin
            s_axi_rdata <= 'd0; // Read time out, give master default value
        end
    end

    always_ff @(posedge aclk) begin
        if (!aresetn) begin
            s_axi_rresp <= 0;
        end else if (rd_state == S_RDWAIT && rd_ack) begin
            s_axi_rresp <= C_RESP_OKAY;
        end else if (rd_state == S_RDWAIT && rd_cnt[4]) begin
            s_axi_rresp <= C_RESP_SLVERR; // Read time out, response a error
        end
    end


    // Write Register
    //---------------

    {% for r in block.registers %}
    // {{ r.name }}

        {% for f in r.fields %}
            {% if f.access == 'RW' or f.access == 'WO' %}
    {{ field_write_proc(r, f) }}

            {% endif %}
        {% endfor %}
    {% endfor %}

    // Read Register
    //--------------

    {{ read_proc(block.registers) }}

    always_ff @(posedge aclk) begin
        if (!aresetn) begin
            rd_ack <= 1'b0;
        end else begin
            rd_ack <= rd_req;
        end
    end

endmodule

`default_nettype wire
